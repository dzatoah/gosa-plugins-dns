<?php



/* This class is inherited from the original 'Tree'
 *  class written by Heiko Hund.
 * It is partly rewritten to create a useable html interface 
 *  for each single sieve token. 
 * This gives us the ability to edit existing sieve filters. 
 */
class My_Tree extends Tree
{
  var $dumpFn_;
  var $dump_;

  var $mode_stack = array();
  var $pap		= array();


  /* Create a html interface for the current sieve filter 
   */
  function dump()
  {
    error_reporting(E_ALL);    
    $this->dump_ = "";
    $this->mode_stack = array();
    $this->pap = array();
    $this->doDump_(0, '', true);

    $this->dump_ ="<table width='100%'><tr><td style='background-color:#BBBBBB;border: 0px;padding-left:20px;'>";
    foreach($this->pap as $object){
      if(is_object($object)){
        $this->dump_ .= preg_replace("/>/",">\n",$object->execute()); 
      }
    }
    $this->dump_ .= "</td></tr></table>";
    return $this->dump_;
  }


  /* This function walks through the object tree generated by the "Parse" class.
   * All Commands will be resolved and grouped. So the Commands and their 
   *  parameter are combined. Like "IF" and ":comparator"...
   */  
  function doDump_($node_id, $prefix, $last,$num = 1)
  {
    /* Indicates that current comman will only be valid for a single line. 
     *  this command type will be removed from mode_stack after displaying it.
     */
    $rewoke_last = FALSE;

    /* Get node */ 
    $node = $this->nodes_[$node_id];

    /* This closes the last mode */
    if($node['class'] == "block-start"){
      $tmp = array_pop($this->mode_stack);
      $this->handle_elements($tmp,$node_id);
      $this->handle_elements(array("TYPE" => "block_start"),$node_id);
    }

    /* This closes the last mode */
    if($node['class'] == "block-end"){
      $tmp = array_pop($this->mode_stack);
      $this->handle_elements($tmp,$node_id);
      $this->handle_elements(array("TYPE" => "block_end"),$node_id);
    }

    /* Semicolon indicates a new command */
    if($node['class'] == "semicolon"){
      $tmp =array_pop($this->mode_stack);
      $this->handle_elements($tmp,$node_id);
    }

    /* Handle comments */
    if($node['class'] == "comment"){
      $this->mode_stack[] = array("TYPE" => $node['class']);
      $rewoke_last = TRUE;
    }

    /* Handle identifiers */
    $identifiers = array("if","elsif","end","reject","redirect","vacation","keep","discard","comment","fileinto","require","stop");
    if($node['class'] == "identifier" && in_array($node['text'],$identifiers)){
      $this->mode_stack[] = array("TYPE" => $node['text']); 
    }

    /* Add current node to current command stack */
    end($this->mode_stack);
    $key = key($this->mode_stack);
    $this->mode_stack[$key]['ELEMENTS'][] = $node;

    /* Remove last mode from mode stack, cause it was only valid for a single line */
    if($rewoke_last){
      $tmp =array_pop($this->mode_stack);
      $this->handle_elements($tmp,$node_id);
    }

    /* If this is a sub element, just call this for all childs */	
    if(isset($this->childs_[$node_id])){
      $childs = $this->childs_[$node_id];
      for ($i=0; $i<count($childs); ++$i)
      {
        $c_last = false;
        if ($i+1 == count($childs))
        {
          $c_last = true;
        }
        $this->doDump_($childs[$i], "", $num);
      }
    }
  }


  /* Create a class for each resolved object.
   * And append this class to a list of objects.
   */
  function handle_elements($data,$id)
  {
    if(!isset($data['TYPE'])){
      return;
    }
    $type = $data['TYPE'];
    
    $class_name= "sieve_".$type ;
    if(class_exists($class_name)){
      $this->pap[] = new $class_name($data,$id);
    }else{
      echo "<font color='red'>Missing : ".$class_name."</font>"."<br>";
    }
  }
}


/* This checks if there is a string at the current position 
 *  in the token array. 
 * If there is a string list at the current position,
 *  this function will return a complete list of all
 *  strings used in this list.
 * It also returns an offset of the last token position 
 */
function sieve_get_strings($data,$id)
{
  $ret = array();
  if($data[$id]['class'] == "left-bracket"){
    while($data[$id]['class']  != "right-bracket" && $id < count($data)){
      
      if($data[$id]['class'] == "quoted-string"){
        $ret[] = $data[$id]['text'];
      }
      $id ++;
    }
  }elseif($data[$id]['class'] == "quoted-string"){
    $ret[] = $data[$id]['text'];
  }elseif($data[$id]['class'] == "number"){
    $ret[] = $data[$id]['text'];
  }
  return(array("OFFSET" => $id, "STRINGS" => $ret));
}

// vim:tabstop=2:expandtab:shiftwidth=2:filetype=php:syntax:ruler:
?>
