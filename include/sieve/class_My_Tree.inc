<?php



/* This class is inherited from the original 'Tree'
 *  class written by Heiko Hund.
 * It is partly rewritten to create a useable html interface 
 *  for each single sieve token. 
 * This gives us the ability to edit existing sieve filters. 
 */
class My_Tree extends Tree
{
  var $dumpFn_;
  var $dump_;

  var $mode_stack = array();
  var $pap		= array();


  /* Create a html interface for the current sieve filter 
   */
  function dump()
  {
    error_reporting(E_ALL);

    /* Only parse the tokens once */
    if(!count($this->pap)){
      $this->dump_ = "";
      $this->mode_stack = array();
      $this->pap = array();
      $this->doDump_(0, '', true);
    }

    /* Create html results */
    $this->dump_ ="<table width='100%'><tr><td style='background-color:#BBBBBB;border: 0px;padding-left:20px;'>";
    foreach($this->pap as $key => $object){
      if(is_object($object)){
        $this->dump_ .= preg_replace("/>/",">\n",$object->execute()); 
      }
    }
    $this->dump_ .= "</td></tr></table>";
    return $this->dump_;
  }


  /* This function walks through the object tree generated by the "Parse" class.
   * All Commands will be resolved and grouped. So the Commands and their 
   *  parameter are combined. Like "IF" and ":comparator"...
   */  
  function doDump_($node_id, $prefix, $last,$num = 1)
  {
    /* Indicates that current comman will only be valid for a single line. 
     *  this command type will be removed from mode_stack after displaying it.
     */
    $rewoke_last = FALSE;

    /* Get node */ 
    $node = $this->nodes_[$node_id];

    /* This closes the last mode */
    if($node['class'] == "block-start"){
      $tmp = array_pop($this->mode_stack);
      $this->handle_elements($tmp,$node_id);
      $this->handle_elements(array("TYPE" => "block_start"),$node_id);
    }

    /* This closes the last mode */
    if($node['class'] == "block-end"){
      $tmp = array_pop($this->mode_stack);
      $this->handle_elements($tmp,$node_id);
      $this->handle_elements(array("TYPE" => "block_end"),$node_id);
    }

    /* Semicolon indicates a new command */
    if($node['class'] == "semicolon"){
      $tmp =array_pop($this->mode_stack);
      $this->handle_elements($tmp,$node_id);
    }

    /* Handle comments */
    if($node['class'] == "comment"){
      $this->mode_stack[] = array("TYPE" => $node['class']);
      $rewoke_last = TRUE;
    }

    /* Handle identifiers */
    $identifiers = array("if","elsif","end","reject","redirect","vacation","keep","discard","comment","fileinto","require","stop");
    if($node['class'] == "identifier" && in_array($node['text'],$identifiers)){
      $this->mode_stack[] = array("TYPE" => $node['text']); 
    }

    /* Add current node to current command stack */
    end($this->mode_stack);
    $key = key($this->mode_stack);
    $this->mode_stack[$key]['ELEMENTS'][] = $node;

    /* Remove last mode from mode stack, cause it was only valid for a single line */
    if($rewoke_last){
      $tmp =array_pop($this->mode_stack);
      $this->handle_elements($tmp,$node_id);
    }

    /* If this is a sub element, just call this for all childs */	
    if(isset($this->childs_[$node_id])){
      $childs = $this->childs_[$node_id];
      for ($i=0; $i<count($childs); ++$i)
      {
        $c_last = false;
        if ($i+1 == count($childs))
        {
          $c_last = true;
        }
        $this->doDump_($childs[$i], "", $num);
      }
    }
  }


  /* Create a class for each resolved object.
   * And append this class to a list of objects.
   */
  function handle_elements($data,$id)
  {
    if(!isset($data['TYPE'])){
      return;
    }
    $type = $data['TYPE'];
    
    $class_name= "sieve_".$type ;
    if(class_exists($class_name)){
      $this->pap[] = new $class_name($data,$id);
    }else{
      echo "<font color='red'>Missing : ".$class_name."</font>"."<br>";
    }
  }

  function save_object()
  {
    foreach($this->pap as $key => $obj){

      if(in_array(get_class($obj),array("sieve_if"))){
        $this->pap[$key]->save_object();
      }
    }
  }

  /* Need to be reviewed */
  function get_sieve_script()
  {
    $tmp ="";
    if(count($this->pap)){
      $tmp = "#Generated by GOsa - Gonicus System Administrator\n";
      $buffer = "";    
      foreach($this->pap as $part)  {
        if(get_class($part) == "sieve_block_end"){
          $buffer = substr($buffer,0,strlen($buffer)-(strlen(SIEVE_INDENT_TAB)));
        }
        $tmp2 = $part->get_sieve_script_part();
        $tmp3 = split("\n",$tmp2);
        foreach($tmp3 as $str){
          $str2 = trim($str);
          if(empty($str2)) continue;
          $tmp.= $buffer.$str."\n";
        }
        if(get_class($part) == "sieve_block_start"){
          $buffer .= SIEVE_INDENT_TAB;
        }
      }
    }
    return($tmp);
  }
}


/* Create valid sieve string/string-list 
 *  out of a given array
 */
function sieve_create_strings($data)
{
  $ret = "";
  if(is_array($data)){
    if(count($data) == 1){
      $ret = "\"";
      foreach($data as $dat){
        $ret .=$dat;
      }
      $ret.="\"";
    }else{
      foreach($data as $dat){
        $ret.= "\"";
        $ret.=$dat;
        $ret.="\", ";
      }
      $ret = preg_replace("/,$/","",trim($ret));
      $ret = "[".$ret."]";
    }
  }else{
    $ret = "\"".$data."\"";
  }
  $ret = preg_replace("/\"\"/","\"",$ret);
  return($ret);
}

/* This checks if there is a string at the current position 
 *  in the token array. 
 * If there is a string list at the current position,
 *  this function will return a complete list of all
 *  strings used in this list.
 * It also returns an offset of the last token position 
 */
function sieve_get_strings($data,$id)
{
  $ret = array();
  if($data[$id]['class'] == "left-bracket"){
    while($data[$id]['class']  != "right-bracket" && $id < count($data)){
      
      if($data[$id]['class'] == "quoted-string"){
        $ret[] = $data[$id]['text'];
      }
      $id ++;
    }
  }elseif($data[$id]['class'] == "quoted-string"){
    $ret[] = $data[$id]['text'];
  }elseif($data[$id]['class'] == "number"){
    $ret[] = $data[$id]['text'];
  }
  return(array("OFFSET" => $id, "STRINGS" => $ret));
}

// vim:tabstop=2:expandtab:shiftwidth=2:filetype=php:syntax:ruler:
?>
